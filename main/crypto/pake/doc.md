# PAKE implementation

Схематически протокол выглядит так:

```
  [Сервер]                           [Клиент]
     |                                   |
     |-- (stored_data, public_data) -->   |   (сервер инициирует данные step0)
     |                                   |
     |<--  Response1: X ---------------  |   (клиент вычисляет X = gx + M)
     |                                   |
     |--  Response2: Y + client_validator  --->  (сервер отвечает, вычисляя Y = gy + N, а также валидаторы)
     |                                   |
     |<--  Response3: server_validator ---|  (клиент проверяет и отправляет серверный валидатор)
     |                                   |
     |--- Проверка сервером --------------> (если всё верно – общий разделённый ключ)
```

Протокол использует вспомогательные функции push/pop для упаковки бинарных данных.

---

В представленном ранее C++‑коде реализована своя версия SPAKE2+, построенная на использовании функций libsodium и работы с кривой ed25519. То есть в C++‑версии описан полный цикл обмена сообщениями (этапы записи и чтения бинарных данных, вычисления точечных сумм, скалярных умножений и формирования общих ключей с подтверждением) – всё это соответствует «трем стадиям» протокола. А вот фрагмент из файла Spake2p.ts – это совсем другой вариант реализации того же протокола (Spake2p), только на языке TypeScript.

Здесь реализованы следующие важные моменты:

- Класс Spake2p управляет состоянием протокола, в том числе хранит параметры контекста, случайное число (эквивалент секретного скаляра) и значение w0, полученное из преобразования PINа.
- Методы computeW0W1 и computeW0L получают пары значений (w0 и w1) из PBKDF2 (с использованием заданного количества итераций и соли), после чего вычисляют L как w1·B (B – базовая точка). Это важная часть, которая в нашей C++‑реализации заменяется вычислением ключей из пароля с помощью crypto_pwhash.
- Методы computeX и computeY вычисляют эфемерные публичные значения X и Y, используя операцию умножения базовой точки на случайное число и добавление констант (M и N, которые задаются в соответствии с проектом SPAKE2+). В C++‑коде это делается через crypto_scalarmult_ed25519_base/crypto_core_ed25519_add, а в TypeScript – через операции над объектами типа ProjectivePoint (на основе кривой P256).
- Методы computeSecretAndVerifiersFromY и computeSecretAndVerifiersFromX выполняют вычисления для получения секрета и контрольных значений (верификаторов) на основе обмена Y (или X) и дополнительно – с использованием HKDF и HMAC, чтобы получить подтверждение совпадения секретной информации участников протокола.
- Внутренний метод computeTranscriptHash создаёт хэш, включающий все критические параметры (контекст, публичные значения, константы и даже значение w0), что позволяет затем получить ключи подтверждения через hkdf.

Таким образом, в TypeScript‑версии тоже охвачены все стадии и вычисления SPAKE2+, но с использованием другого набора криптографических примитивов (например, для P256 вместо ed25519) и другого подхода к управлению сериализацией данных (через DataWriter и типизированные методы).
Если сравнивать с приведённым C++‑кодом, то можно сказать, что оба решения реализуют один и тот же протокол обмена, но в TypeScript‑варианте дополнительно реализованы этапы получения w0/w1 из PINа (с применением pbkdf2), формирование L, а также построение транскрипта для hkdf, что может показаться «дополнительным видом» реализации. Они демонстрируют разные подходы и выбор криптографических примитивов в зависимости от среды (P256 в TS vs. Ed25519 в нашем C++‑примере).

---

Ниже приведён пример кода на C++ для получения значений w₀ и w₁ из PIN с использованием PBKDF2 (через OpenSSL) и последующего сведения их по модулю порядка эллиптической кривой P‑256. То есть, аналог функции computeW0W1 из TypeScript. Для компиляции потребуется OpenSSL (lcrypto).

Код содержит следующие шаги:

- Представление PIN в виде 4‑байтного значения (little‑endian).
- Вычисление PBKDF2‑вывода длиной 80 байт (40 байт для w₀ и 40 для w₁) с использованием HMAC‑SHA256.
- Преобразование полученных байтов в BIGNUM (большие целые) в формате Big‑endian.
- Взятие остатков по модулю порядка n для P‑256 (константа n приведена в шестнадцатеричном виде).

---

Пояснения к коду:

- Функция uint32_to_le_bytes записывает PIN в 4‑байтный массив в формате little‑endian.
- PBKDF2 (PKCS5_PBKDF2_HMAC) получает пароль (PIN в виде 4 байт), соль, число итераций и вычисляет 80 байт вывода.
- Первые 40 байт используются для формирования w₀, остальные – для w₁. Полученные BIGNUM приводятся по модулю порядка n (заданного для P‑256).
- Для больших чисел используются функции OpenSSL (BN_new, BN_mod, BN_bin2bn, BN_bn2hex).
- Соль генерируется случайно (функция RAND_bytes).

Таким образом, приведённый код реализует тот же алгоритм, что и в версии на TypeScript, но адаптирован для C++ с использованием OpenSSL.

---

Ниже приведён минималистичный пример реализации SPAKE2p на эллиптической кривой P‑256 на C++ с использованием OpenSSL. В этом примере реализована получение w₀/w₁ из PIN (как в предыдущем примере), а также класс Spake2p, который создаёт эфемерное состояние, вычисляет публичные значения X и Y по формулам

`X = G·r + M·w₀  и  Y = G·r + N·w₀`

а также вычисляет секрет (точнее, промежуточные значения Z и V) и его «подтверждения» (верификаторы) на основе переданных данных. Константы M и N заданы в виде компактных точечных представлений в формате SEC(compressed). Реальная схема протокола включает ещё схему хэширования транскрипта (HKDF, HMAC и т.п.), здесь для примера ключевой момент вычислений показан схематически.

---

Алгоритм:

- Из PIN (4 байта little‑endian) и соли с помощью PBKDF2 получаем 80 байт. Первые 40 байт формируют w₀, оставшиеся – w₁; затем обе величины приводятся по модулю порядка n кривой P‑256.
- Константы M и N (точки на кривой) задаются согласно конфигурации SPAKE2+.
- Класс Spake2p создаётся с контекстом (произвольный байтовый массив), секретным скаляром r (random) и извлечённым w₀.
- Вычисляются X = G·r + M·w₀ и Y = G·r + N·w₀.
- В методе computeSecretAndVerifiersFromY показывается схема вычисления: берётся Y′ = Y – (N·w₀) и затем Z = Y′ · r,  V = Y′ · w₁.
- После чего транскрипт (включающий контекст, значения точек, константы и w₀) хэшируется; его части используются для получения ключей подтверждения (HKDF/HMAC).

(В примере ниже детали HKDF/HMAC опущены – можно использовать EVP_PKEY_HKDF и HMAC.)

---

Пояснения к коду:

- Функция computeW0W1 получает 80-байтный вывод PBKDF2 (с PIN, преобразованным в 4‑байта little‑endian, и заданной солью). Первый блок (40 байт) интерпретируется как w₀, второй – как w₁; затем значения редуцируются по модулю порядка n для кривой P‑256.
- Класс Spake2p создаёт группу (P‑256) и задаёт константы M и N на основе их SEC‑компрессированного представления. Метод create генерирует случайный скаляр r.
- Методы computeX и computeY вычисляют X и Y по формулам SPAKE2p.
- Метод computeSecretAndVerifiersFromY демонстрирует схему получения Y′, Z и V; далее транскрипт (состоящий из контекста, точечных представлений и w₀) хэшируется – на его основе далее можно вывести ключи подтверждения посредством HKDF/HMAC (в примере эти вычисления упрощены).

---

Ниже приведён минималистичный пример на C++ (с использованием OpenSSL), в котором выделены три этапа ­– PasePake1, PasePake2 и PasePake3. Пример исключает детали обмена сообщениями, сессий и пр. Он лишь демонстрирует, как клиент на этапе 1 вычисляет X («PasePake1»), сервер на этапе 2 получает X, вычисляет Y и серверный верификатор («PasePake2»), а затем клиент на этапе 3, получив Y и верификатор с сервера, проверяет корректность и подготавливает ответ («PasePake3»), а сервер проверяет его.

В этом примере используются следующие идеи (на кривой P‑256):

- Из заданного PIN с помощью PBKDF2 вычисляются два скалярных значения w₀ и w₁ (см. функцию computeW0W1).
- Клиент и сервер используют общее значение w₀; сервер дополнительно вычисляет L = G·w₁ (аналог функции computeW0L в TS‑коде).
- Для обмена используются объект Spake2p, который при создании принимает контекст и значение w₀; его методы computeX() и computeY() вычисляют X = G·r + M·w₀ и Y = G·r + N·w₀ (где M и N – константы, задаваемые в SEC‑compressed виде).
- На этапе 2 сервер (зная L) вычисляет секрет и оба верификатора по функции computeSecretAndVerifiersFromX(L, X, Y).
- На этапе 3 клиент получает Y, вычисляет секрет через computeSecretAndVerifiersFromY(w₁, X, Y) и сверяет полученный “клиентский” верификатор с серверным; затем отправляет серверу свой верификатор, который сервер сравнивает с ожидаемым.

---

Пояснения к коду:

- Функция computeW0W1 берёт PIN (у нас – 123456) и случайную соль (16 байт) и возвращает два BIGNUM’а w₀ и w₁, редуцированные по модулю порядка P‑256. (Эта часть соответствует вычислению PBKDF2 в TypeScript.)
- Функция computeL вычисляет L = G·w₁ – аналог вычисления L в TypeScript через computeW0L.
- Класс Spake2p создаётся с общим контекстом и значением w₀, а его методы computeX() и computeY() вычисляют эфемерные публичные значения X и Y.
- На стороне сервера метод computeSecretAndVerifiersFromX(L, X, Y) вычисляет секретные значения и два верификатора: один для клиента (hAY) и один для передачи клиенту (hBX).
- На стороне клиента аналогичная функция computeSecretAndVerifiersFromY(w₁, X, Y) возвращает секрет и верификаторы. Клиент сверяет полученный hBX с серверным и отправляет hAY, который сервер проверяет.
- В реальной реализации вместо простого копирования байт из хэша следует применять HKDF и HMAC для формирования окончательных ключей; в примере схема упрощена.

Таким образом, даже если в реальном протоколе дополнительно реализуются обмен сообщениями, установка сессий и т.д., данный пример показывает чистую вычислительную логику этапов PasePake1, PasePake2 и PasePake3 на языке C++.
