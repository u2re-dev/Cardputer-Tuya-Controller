#pragma once
#ifndef ECC_HPP
#define ECC_HPP

//
#include "../../std/math.hpp"
#include "../../std/hex.hpp"

//?======================================================
//? Curves Predeclated

#define USE_CURVE_P256
// #define USE_BLS12_381
// #define USE_CURVE_SECP256K1
// #define USE_CURVE_P521

//
static const bigint_t B256 = (bigint_t(1) << 256);

/**
 * @struct CurveParameters
 * @brief Holds the parameters of an elliptic curve.
 *
 * This structure stores the essential parameters that define an elliptic curve over a finite field.
 * These include the coefficients 'a' and 'b' of the elliptic curve equation y^2 = x^3 + ax + b,
 * the prime 'p' defining the finite field size, the coordinates 'Gx' and 'Gy' of the generator
 * point, and 'n' which is the order of the group generated by the generator point.
 */
struct CurveParameters {
    // defaultly USE_CURVE_P256
    bigint_t a  ;//= bigint_t("ffffffff00000001000000000000000000000000fffffffffffffffffffffffc", 16);  ///< Coefficient a of the elliptic curve equation.
    bigint_t b  ;//= bigint_t("5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b", 16);  ///< Coefficient b of the elliptic curve equation.
    bigint_t p  ;//= bigint_t("ffffffff00000001000000000000000000000000ffffffffffffffffffffffff", 16); //B256 - bigint_t("1000003d1", 16);  ///< Prime number defining the field size.
    bigint_t Gx ;//= bigint_t("6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296", 16); ///< x-coordinate of the generator point.
    bigint_t Gy ;//= bigint_t("4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5", 16); ///< y-coordinate of the generator point.
    bigint_t n  ;//= bigint_t("ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551", 16); //B256 - bigint_t("14551231950b75fc4402da1732fc9bebf", 16);  ///< Order of the group generated by the generator point.
};



//?======================================================
//? ECC Point Class Declaration

/**
 * @class eccp_t
 * @brief Represents a point on an elliptic curve.
 *
 * The eccp_t class encapsulates a point on an elliptic curve defined over a finite field.
 * It provides functionalities for elliptic curve arithmetic like point addition,
 * negation, and scalar multiplication.
 */
class eccp_t {
public:
    //?======================================================
    //? Curve Specific

    /**
     * @brief Retrieves a constant reference to the curve parameters.
     *
     * This static function provides access to the elliptic curve parameters used by all instances of eccp_t.
     * It ensures that the curve parameters are initialized only once and then reused for any subsequent calls,
     * improving efficiency and consistency across eccp_t instances.
     *
     * The function works by creating a temporary eccp_t object to trigger the initialization of curve parameters
     * within the constructor of eccp_t. These parameters are then copied to a static CurveParameters variable,
     * which is returned by reference to the caller.
     *
     * @note This function is thread-safe only if the compiler guarantees the thread-safe initialization of local static variables.
     *
     * @return A constant reference to the statically stored CurveParameters object, ensuring that all eccp_t instances
     * share the same set of elliptic curve parameters.
     */

    //
    //static CurveParameters GetCurveParameters();
    static eccp_t getM() { return eccp_t::fromHex("02886e2f97ace46e55ba9dd7242579f2993b64e16ef3dcab95afd497333d8fa12f"); }
    static eccp_t getN() { return eccp_t::fromHex("03d8bbd6c639c62937b04d997f38c3770719c629d7014d49a24b4f98baa1292b49"); }
    static eccp_t getBase() { 
        auto params = GetCurveParameters();
        return eccp_t(params.Gx, params.Gy, 1);
    }
    static bigint_t getCurveOrder() { return bigint_t("ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551", 16); }
    static bigint_t getP() { return GetCurveParameters().p; }


    //?======================================================
    //? Constructors Specific

    /**
     * @brief Default constructor to initialize an eccp_t with bigint_t coordinates. Initializes with base points as x and y coordinate.
     * @param x The x-coordinate of the eccp_t.
     * @param y The y-coordinate of the eccp_t.
     */
    eccp_t() : xCoord(bigint_t(static_cast<unsigned long int>(0))), yCoord(bigint_t(static_cast<unsigned long int>(0))), isInfinity(true) {}

    /**
     * @brief Constructor to initialize an eccp_t with bigint_t coordinates.
     * @param x The x-coordinate of the eccp_t.
     * @param y The y-coordinate of the eccp_t.
     */
    eccp_t(const bigint_t& x, const bigint_t& y, const bigint_t& z = 1) : xCoord(x), yCoord(y), zCoord(z), isInfinity(false) { setCurveParameters(); }

    /**
     * @brief Copy constructor.
     * @param other The eccp_t to copy.
     */
    eccp_t(eccp_t const& other) : xCoord(other.xCoord), yCoord(other.yCoord), isInfinity(other.isInfinity), curveParams(other.curveParams) {}


    //?======================================================
    //? Operators

    /**
     * @brief Overloads the == operator to compare two eccp_ts.
     *
     * This function checks if two points on the elliptic curve are equal. Two points
     * P = (x1, y1) and Q = (x2, y2) are considered equal if and only if x1 ≡ x2 and
     * y1 ≡ y2. This comparison is crucial in many cryptographic algorithms to determine
     * if two points are the same.
     *
     * The equality check is performed under modulo p arithmetic for a prime field.
     *
     * @param other The eccp_t to compare with this point.
     * @return True if the points are equal (both x and y coordinates match), false otherwise.
     */
    bool operator==(eccp_t const& other) const {
        if (isInfinity && other.isInfinity) return true;
        if (isInfinity || other.isInfinity) return false;
        return (xCoord == other.xCoord) && (yCoord == other.yCoord) && (zCoord == other.zCoord);
    }



    eccp_t operator-(eccp_t const& other) const {
        return (*this) + (-other);
    }


    /**
     * @brief Overloads the + operator for adding two eccp_ts.
     *
     * This function implements the addition of two points on an elliptic curve.
     * Given two points P = (x1, y1) and Q = (x2, y2), it computes the resulting
     * point R = P + Q = (x3, y3) using elliptic curve addition formulas.
     *
     * The addition is defined as follows:
     * 1. If P = Q, then the point doubling formula is applied.
     * 2. If P ≠ Q, the slope λ = (y2 - y1) / (x2 - x1) is computed, followed by
     *    x3 = λ² - x1 - x2 and y3 = λ(x1 - x3) - y1.
     * 3. Special cases, like handling the point at infinity, are also considered.
     *
     * Operations are performed under modulo p arithmetic for a prime field.
     *
     * @param other The eccp_t to add to this point.
     * @return eccp_t representing the sum of this point and the other point.
     */
    eccp_t operator+(eccp_t const& other) const {
        if (this->isInfinity) return other;
        if (other.isInfinity) return *this;
        if (*this == -other) return eccp_t();
        if (*this == other) { return this->doublePoint(); }

        //
        bigint_t lambda = (other.yCoord - yCoord) * (bmath::inv(other.xCoord - xCoord, curveParams.p));
        bigint_t x3 = (lambda * lambda - xCoord - other.xCoord) % curveParams.p;
        bigint_t y3 = (lambda * (xCoord - x3) - yCoord) % curveParams.p;
        return eccp_t(x3, y3);
    }

    /**
     * @brief Overloads the - operator to negate this eccp_t.
     *
     * Negating a point P = (x, y) on the elliptic curve results in the point -P = (x, -y).
     * In the context of modulo arithmetic for a prime field, -y is computed as p - y.
     *
     * This operation is useful for elliptic curve point subtraction, as P - Q is equivalent
     * to P + (-Q).
     *
     * @return eccp_t representing the negation of this point on the elliptic curve.
     */
    eccp_t operator-() const {
        if (this->isInfinity) return *this;
        return eccp_t(xCoord, curveParams.p - yCoord);
    }

    /**
     * @brief Overloads the * operator for scalar multiplication of this eccp_t.
     *
     * Scalar multiplication is a fundamental operation in elliptic curve cryptography.
     * It computes kP for a point P on the curve and a scalar k. This operation is
     * equivalent to adding P to itself k times.
     *
     * The scalar multiplication is performed using the "double-and-add" method, which
     * is efficient and reduces the number of elliptic curve operations needed.
     *
     * @param scalar The bigint_t scalar to multiply this point by.
     * @return eccp_t resulting from the scalar multiplication of this point by the scalar.
     */
    eccp_t operator*(const bigint_t& scalar) const {
        if (scalar == 0 || this->isInfinity) { return eccp_t(); }
        eccp_t result;
        eccp_t point = *this;

        bigint_t k = scalar;
        while (k > bigint_t(static_cast<unsigned long int>(0))) {
            if (k % bigint_t(static_cast<unsigned long int>(2)) != bigint_t(static_cast<unsigned long int>(0))) {
                result = result + point;
            }
            point = point.doublePoint();
            k /= bigint_t(static_cast<unsigned long int>(2));
        }
        return result;
    }

    /**
     * @brief Assignment operator.
     * @param other The eccp_t to assign.
     * @return Reference to this eccp_t after assignment.
     */
    eccp_t& operator=(eccp_t const& other) {
        if (this != &other) {
            xCoord = other.xCoord;
            yCoord = other.yCoord;
            isInfinity = other.isInfinity;
            curveParams = other.curveParams;
        }
        return *this;
    }



    //?======================================================
    //? Operations

    //
    //static eccp_t fromAffine(const affine_t &pt);

    //
    affine_t toAffine() const;

    //
    eccp_t multiply(const bigint_t &scalar) const;

    //
    bool equals(const eccp_t &other) const;


    /**
     * @brief Doubles this eccp_t on the elliptic curve.
     *
     * This function implements the point doubling operation for elliptic curves
     * in Weierstrass form. It calculates 2P = (x', y') for the current point P = (x, y).
     * The doubling is done using the formulas: λ = (3x² + a) / 2y, x' = λ² - 2x,
     * and y' = λ(x - x') - y, where 'a' is the curve parameter and operations are
     * performed under modulo p arithmetic, with p being the prime order of the field.
     * The point P is represented by the member variables xCoord and yCoord.
     *
     * @note Assumes the point is not at infinity and y-coordinate is not zero.
     * Additional handling is required for these special cases.
     *
     * @return eccp_t representing the doubled point 2P on the elliptic curve.
     */
    eccp_t doublePoint() const;

    /**
     * @brief Get the x-coordinate of the eccp_t.
     * @return The x-coordinate.
     */
    const bigint_t& getX() const { return xCoord; }

    /**
     * @brief Get the y-coordinate of the eccp_t.
     * @return The y-coordinate.
     */
    const bigint_t& getY() const { return yCoord; }

    /**
     * @brief Set the x-coordinate of the eccp_t.
     * @param x The new x-coordinate.
     */
    void setX(const bigint_t& x) { xCoord = x; }

    /**
     * @brief Set the y-coordinate of the eccp_t.
     * @param y The new y-coordinate.
     */
    void setY(const bigint_t& y) { yCoord = y; }




    //?======================================================
    //? Debug and bytes_t operation (conversion)

    /**
     * @brief Prints the coordinates of the eccp_t.
     *
     * This function displays the x and y coordinates of the eccp_t. If the point
     * is at infinity, it prints a message indicating so. This is useful for debugging
     * and verifying the values of the eccp_t during computations.
     */
    void print() const;

    // Парсинг точки из hex‑строки (поддерживается как сжатый, так и несжатый формат).
    // Для сжатого формата: 33 байта (первый байт – 0x02 или 0x03, далее 32 байта x).
    //static eccp_t fromHex(const std::string &hexStr);
    //static eccp_t fromBytes(const bytes_t &bytes);
    //static std::string n2h(const bigint_t &num);

    //
    //bytes_t toRawBytes(bool isCompressed = true) const; // deprecated method
    bytes_t toBytes(bool isCompressed = true) const;
    void toBytes(uint8_t* output, bool isCompressed = true) const;
    std::string toHex(bool isCompressed) const;

    //
    eccp_t assertValidity() const;





    //
    static eccp_t fromAffine(const affine_t &pt) {
        if(pt.x == 0 && pt.y == 0) return eccp_t(0, 1, 0);
        return eccp_t(pt.x, pt.y, 1);
    }

    //?======================================================
    //? HEX and bytes ops

    //
    static eccp_t fromBytes(const bytes_t& bytes) {
        size_t len = bytes.size();
        if (len != 33 && len != 65) throw std::runtime_error("Invalid point bytes length");

        // get first 32-bytes
        bytes_t xb(bytes.begin() + 1, bytes.begin() + 1 + 32);
        bigint_t x = hex::b2n(xb);
        
        //
        auto curveParams = GetCurveParameters();

        // compressed
        if (len == 33) {
            if (x <= 0 || x >= curveParams.p) throw std::runtime_error("Point bytes invalid: x not FE");
            bigint_t lambda = bmath::mod(bmath::curve(x, curveParams.b, curveParams.p), curveParams.p); // вычисляем x^3+7 mod P
            bigint_t y      = bmath::squareRootBI(lambda);
            bool isYOdd     = (y & 1) == 1;
            bool headOdd    = (xb[0] & 1) == 1;
            if(isYOdd != headOdd) y = bmath::mod(-y, curveParams.p);
            return eccp_t(x, y, 1).assertValidity();
        }

        // uncompressed
        if (len == 65 && bytes[0] == 0x04) {
            bytes_t xB(bytes.begin() + 1     , bytes.begin() + 1 + 32);
            bytes_t yB(bytes.begin() + 1 + 32, bytes.end()           );
            bigint_t xVal = hex::b2n(xB);
            bigint_t yVal = hex::b2n(yB);
            return eccp_t(xVal, yVal, 1).assertValidity();
        }

        //
        throw std::runtime_error("Point invalid: not on curve");
    }

    //
    static eccp_t fromHex(const std::string &hexStr) {
        bytes_t hex = hex::hexToBytes(hexStr);
        return fromBytes(hex);
    }

    //?======================================================
    //? Curves definitions

    //
    static const CurveParameters GetCurveParameters() {
        static CurveParameters staticCurveParams;
        static bool initialized = false;
        if (!initialized) {
            eccp_t temp;
            temp.setCurveParameters();
            temp.isInfinity=false;
            staticCurveParams = temp.curveParams;
            initialized = true;
        }
        return staticCurveParams;
    }





    //
    bool isInfinity;
private:
    CurveParameters curveParams;
    bigint_t xCoord; ///< The x-coordinate of the eccp_t.
    bigint_t yCoord; ///< The y-coordinate of the eccp_t.
    bigint_t zCoord = 1;

    /**
     * @brief Sets the parameters of the elliptic curve based on the selected curve type.
     *
     * This function initializes the curve parameters (a, b, p, Gx, Gy, n) of the eccp_t
     * object based on a predefined set of well-known elliptic curves. The specific curve
     * is selected using preprocessor directives at compile time. This function is invoked
     * during the construction of an eccp_t object to ensure it is configured with the
     * correct parameters for the chosen elliptic curve.
     *
     * @note The curve parameters must be predefined and correctly set for the specified
     *       elliptic curve. If no curve is defined, a compile-time error is generated.
     */
    void setCurveParameters();
};

#endif // ECC_HPP
